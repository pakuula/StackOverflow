# Модуль для проверки простоты чисел и сравнения различных алгоритмов проверки простоты

Модуль содержит функции для проверки простоты чисел с использованием различных алгоритмов, а также инструменты для сравнения их производительности.

## Проверка простоты чисел перебором

Базовый алгоритм проверки простоты чисел заключается в переборе делителей до квадратного корня из числа. Этот метод эффективен для чисел до 10^6.

С каждой функцией проверки простоты есть ассоциированная функция поиска делителей.

`find_divisor_basic(n: int) -> Optional[int]` - Находит наименьший делитель числа n, используя перебор. Возвращает None, если число простое. Выбрасывает `ValueError` для `n < 2`.

Связанная функция: `is_prime_basic(n: int) -> bool` - Проверяет, является ли число n простым, используя перебор делителей. Возвращает True, если число простое, иначе False. Выбрасывает `ValueError` для `n < 2`.

Особенность `find_divisor_basic` заключается в том, что после проверки на чётность, перебираются только нечетные числа, что ускоряет процесс проверки.

### Ускорение перебора делителей

Для ускорения перебора делителей можно фильтровать кандидатов на делители, исключая числа, кратные малым простым числам. Это значительно сокращает количество проверок.

Идея алгоритма на примере фильтрации кандидатов на делители по модулю `2` и `3`. Рассмотрим кандидатов на делители в виде последовательности: `6k, 6k+1, 6k+2, 6k+3, 6k+4, 6k+5`, где `k` - целое положительное число.

- `6k` - кратно 2 и 3
- `6k+1` - потенциальный делитель
- `6k+2` - кратно 2
- `6k+3` - кратно 3
- `6k+4` - кратно 2
- `6k+5` - потенциальный делитель

Таким образом, остаются только кандидаты вида `6k+1` и `6k+5`, что уменьшает количество проверок. Перебор начинается с `5` и продолжается с переменным шагом 2 и 4: `5, 7, 11, 13, 17, 19, 23, 25, ...`. В теории это ускоряет проверку примерно в полтора раза по сравнению с простым перебором всех нечетных чисел. Но на практике выигрыша нет, так как перебор остатоков от деления на малые простые числа занимает больше времени, чем экономится на уменьшении количества проверок.

Однако уже для случая фильтрации по модулям `2`, `3` и `5` наблюдается реальное ускорение. Модуль `primes.compare` содержит сравнение различных функций проверки простоты, включая эти оптимизации.

**Список функций проверки простоты:**

- `is_prime_3(n: int) -> bool` - Проверка с фильтрацией по модулям 2 и 3. Парная к ней функция поиска делителей `find_divisor_3(n: int) -> Optional[int]`.
- `is_prime_5(n: int) -> bool` - Проверка с фильтрацией по модулям 2, 3 и 5. Парная к ней функция поиска делителей `find_divisor_5(n: int) -> Optional[int]`.
- `is_prime_7(n: int) -> bool` - Проверка с фильтрацией по модулям 2, 3, 5 и 7. Парная к ней функция поиска делителей `find_divisor_7(n: int) -> Optional[int]`.
- `is_prime_11(n: int) -> bool` - Проверка с фильтрацией по модулям 2, 3, 5, 7 и 11. Парная к ней функция поиска делителей `find_divisor_11(n: int) -> Optional[int]`.
- `is_prime_13(n: int) -> bool` - Проверка с фильтрацией по модулям 2, 3, 5, 7, 11 и 13. Парная к ней функция поиска делителей `find_divisor_13(n: int) -> Optional[int]`.
- `is_prime_17(n: int) -> bool` - Проверка с фильтрацией по модулям 2, 3, 5, 7, 11, 13 и 17. Парная к ней функция поиска делителей `find_divisor_17(n: int) -> Optional[int]`.
- `is_prime_19(n: int) -> bool` - Проверка с фильтрацией по модулям 2, 3, 5, 7, 11, 13, 17 и 19. Парная к ней функция поиска делителей `find_divisor_19(n: int) -> Optional[int]`.

**Nota bene:** для функций `is_prime_13`, `is_prime_17` и `is_prime_19` начальная инициализация фильтров занимает значительное время, поэтому рекомендуется предварительный вызов этих функций перед использованием в производительных задачах.

#### Класс для генерации шагов фильтрации

Класс `FilteringPrimeChecker` реализует генерацию шагов фильтрации делителей на основе заданного набора малых простых чисел. Это позволяет создавать функции проверки простоты с различными уровнями фильтрации.

`FilteringPrimeChecker(max_prime: int)` - Инициализирует генератор шагов фильтрации до заданного максимального простого числа.

Число шагов фильтрации факториально растёт с увеличением `max_prime`, поэтому для больших значений рекомендуется использовать ленивые итераторы шагов. Так, для `max_prime=19` время генерации составляет порядка 1 секунды, а для `max_prime=23` - в 20 раз больше. Соответственно, для `max_prime=29` время генерации будет в 30 раз больше, что делает его непрактичным для использования.

#### Ленивые итераторы шагов

Класс `FilteringPrimeChecker` генерирует все шаги фильтрации сразу, что может быть неэффективно для больших наборов малых простых чисел. Для решения этой проблемы реализованы ленивые итераторы шагов. Эти итераторы генерируют шаги по мере необходимости, что значительно снижает время инициализации, хотя и замедляет сам процесс проверки простоты.

`LazyStepsGenerator(max_prime: int)` - Инициализирует ленивый генератор шагов фильтрации до заданного максимального простого числа.

`LazyStepsIterator(lazy_generator: LazyStepsGenerator)` - Итератор для ленивого генератора шагов фильтрации.

**Пример использования:**

```python
lazy_generator = LazyStepsGenerator(19)
iterator = LazyStepsIterator(lazy_generator)
candidate = 1
candidates = []
for _, step in zip(range(10), iterator):
    candidate += step
    candidates.append(candidate)
print(candidates)
```

Вывод:

```text
[23, 29, 31, 37, 41, 43, 47, 53, 59, 61]
```

В отличие от полного генератора шагов, ленивый генератор позволяет быстро начать процесс проверки простоты без длительной инициализации всех шагов.

## Проверка простоты с помощью теста Миллера-Рабина

Для проверки простоты больших чисел используется вероятностный тест Миллера-Рабина, который эффективен и быстр.

`is_prime_miller_rabin(n: int, k: int = None) -> bool` - Проверяет, является ли число n простым с помощью теста Миллера-Рабина. Параметр k определяет количество раундов теста для повышения точности. Выбрасывает `ValueError` для `n < 2`.

Если параметр k не задан, функция автоматически выбирает количество раундов на основе величины n для обеспечения высокой достоверности результата.

## Поиск ближайшего простого числа

`next_prime(candidate: int, direction: Direction = Direction.FORWARD) -> int` - Находит следующее (или предыдущее) простое число относительно заданного кандидата. Параметр direction определяет направление поиска (вперёд или назад). Выбрасывает `ValueError`, если нет простых чисел в заданном направлении (например, для поиска предыдущего простого числа от 2).

`next_prime_forward(start: int) -> int` - обёртка для поиска следующего простого числа. Результат будет строго больше start.

`next_prime_backward(start: int) -> int` - обёртка для поиска предыдущего простого числа. Результат будет строго меньше start.
